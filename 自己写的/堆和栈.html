<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body></body>
</html>
<script>
    //堆内存是存放引用数据类型的值 对象存的是属性名和属性值，函数存的是函数的代码字符串
    //遇见对象马上就开一个堆内存
    var obj1 = {name: "yangchongduo"};
    var obj2 = obj1;
    //首先进行预解释 var  obj1 var obj2  对引用数据类型而言，只有函数在预解释的时候才会将代码存起来
    //然后代码执行  遇见一个obj1 开辟一个堆内存， 外边的变量知道了，当前的堆内存被占用了，就不能销毁了
    //想要销毁，不是null也可以，1,2等等都行，只要不是那个地址就行，
    obj1 = null;//null是个空指针，那就没有知道这个，浏览器会在空闲的时间会回收这个空间，
    obj2 = null;
    //谷歌浏览器会过一段时间来从头到尾查看一次没有用到的地址，看看有没有在使用，没有使用将其清除。IE和火狐利用的是计数器的原理：当这个堆内存被占用的时候会计数1，被obj2占用的时候会+1，当obj1不占用的时候就会—1，当这个数等于0的时候，这个内存就被释放掉，IE记着数他就不行了，这叫浏览器的内存泄漏，如何处理，高程3里面有最后两章。
    //栈内存，就是作用域，全局作用域，私有作用域(只有函数执行才有作用域)，if switch for那叫代码块，
    //全局作用域，只有浏览器关闭的时候才会销毁；
    //私有作用域：一般情况下，函数会执行会形成一个新的私有作用域，当私有所用域中的执行完成后，我们的当前作用域都会主动的释放和销毁。还是存在特殊情况的，
    //当前私有作用域中的部分内存被作用域之外的东西占用了，这个作用域就不能销毁，
    // 1）大函数执行返回一个引用数据类型的值，这个值被外面的接收了，这种情况下不会被销毁，返回的是引用数据类型，才不能销毁，原因是引用数据类型在作用域里面开辟了一个堆内存，这个堆内存的地址被外面的使用，所以不能销毁，返回的是基本数据类型就销毁，
    //  function fn(){
    //        var num=12;
    //        return function(){
    //
    //
    //        }
    //    }
    //    var f=fn()//fn形成的这个私有作用域不能销毁，
//这种情况下自执行函数的栈内存也不会被销毁，
</script>